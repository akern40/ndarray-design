use std::fmt::Debug;

use super::ArrayBase;

/// A trait representing how an array is laid out, including:
///     1. Shape
///     2. Type of index, i.e., the type for array[index_type]
pub trait Layout {
    /// The type used to index into the array.
    type Indexer;

    /// For fixed-size dimension representations, this should be
    /// `Some(ndim)`, and for variable-sized representations this
    /// should be `None`.
    const NDIM: Option<usize>;

    /// Convert from a reference to the `Indexer` type into a
    /// linear offset from the "start" of the array.
    ///
    /// **Panics** if `i` is out of bounds for the array.
    fn to_offset(i: &Self::Indexer) -> usize;

    /// Returns the number of dimensions (number of axes).
    fn ndim(&self) -> usize;

    /// Compute the size of the dimension (number of elements)
    fn size(&self) -> usize {
        self.slice().iter().product()
    }

    /// Compute the size while checking for overflow.
    fn size_checked(&self) -> Option<usize> {
        self.slice()
            .iter()
            .try_fold(1_usize, |s, &a| s.checked_mul(a))
    }

    #[doc(hidden)]
    fn slice(&self) -> &[usize];

    #[doc(hidden)]
    fn slice_mut(&mut self) -> &mut [usize];

    #[doc(hidden)]
    fn equal(&self, rhs: &Self) -> bool {
        self.slice() == rhs.slice()
    }
}

/// A trait representing the underlying storage of the array.
/// Its main job is to translate linear offsets (generated by
/// the `Layout` trait) to references to the underlying data.
pub trait Storage {
    /// The element type of the underlying array.
    type Elem;
}

pub trait PointerStorage: Storage {
    /// Get a mutable raw pointer to the underlying data.
    ///
    /// # Safety
    ///
    /// The caller must ensure that the underlying data is safe to mutate.
    unsafe fn as_ptr(&self) -> *mut Self::Elem;

    /// Get a reference to the element type from an offset.
    /// The offset is the number of elements from the "origin" of the array.
    ///
    /// # Safety
    ///
    /// The caller must ensure that the offset is within bounds of the array.
    /// This should be done in [`Layout::to_offset`], which should generate
    /// the input to this function.
    unsafe fn ref_from_offset(&self, offset: usize) -> &Self::Elem;

    /// Get a mutable reference to the element type from an offset.
    /// The offset is the number of elements from the "origin" of the array.
    ///
    /// # Safety
    ///
    /// 1. The caller must ensure that the offset is within bounds of the array.
    /// This should be done in [`Layout::to_offset`], which should generate
    /// the input to this function.
    ///
    /// 2. The caller must ensure that the data being accessed is uniquely held.
    /// This should be done by
    unsafe fn ref_mut_from_offset(&mut self, offset: usize) -> &mut Self::Elem;
}

pub unsafe trait Backend {
    type Ref: Debug;
    type Owned: Debug;
    type Elem;

    /// Ensure that an owned array has unique access to its data.
    ///
    /// If the input array is contiguous, then the output must have
    /// the same strides as the input.
    fn ensure_unique<L>(arr: &mut ArrayBase<L, Self>)
    where
        Self: Sized,
        L: Layout;

    /// Return whether the array has unique access to its data.
    fn is_unique<L>(arr: &mut ArrayBase<L, Self>) -> bool
    where
        Self: Sized;

    fn ref_from_owner_offset(owner: &mut Self::Owned, offset: isize) -> Self::Ref;
}
